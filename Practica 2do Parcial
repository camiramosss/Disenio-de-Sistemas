// PRACTICA PARCIALES DISEÑO DE SISTEMAS (2DO PARCIAL)

//-------------------------------------SWORDGO-------------------------------------
// --- ORM ---
// para no repetir logica de Id (aunque el @Entity siempre debe estar)

import java.time.DateTimeException;

@MappedSuperclass
public abstract class PersistanceEntity{
    @Id
    @GeneratedValue
    private int id;
    // getter --> en parcial no hace falta I guess
    public int getID() {return id;}
}

// Personaje --> clase principol
// uso SET en las colecciones ya que no me importa el orden (y no permito duplicados para evitar ineficiencia en la DB)
// para el *-* uso JoinTable (le pongo nombre a la tabla intermedia)
// aclaro la FK de inventario (y el resto) para que hibernate no se confunda con la de armas/accesorios en uso, ya que todos son item (muchas relaciones a la misma clase --> @JoincColumn)
// ademas el @JoinColumn evita la tabla intermedia innecesaria para las relaciones 1-*
@Entity
public class Personaje extends PersistanceEntity{
    String nombre;
    Int moneda;
    
    @Enumerated
    TipoPersonajeEnum rol;

    @ManyToMany
    @JoinTable(name = ubicacionPorPersonaje)
    Set <Ubicacion> ubicacionesVisitadas;

    @OneToMany
    @JoinColumn(name = inventario_id)
    Set <Item> inventario;

    @OneToMany
    @JoinColumn(name = armasEnUso_id)
    Set <Arma> armasEnUso;

    @OneToMany
    @JoinColumn(name = accesoriosEnUso_id)
    Set <Accesorio> accesoriosEnUso;
}

// Item --> JOINED
// tenemos atributos en común, pero otros no
// debemos permitir polimorfismo, y en otros casos no (métodos propios)
// no hay tantas tablas para que el joined nos baje la performance
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public abstract class Item extends PersistanceEntity{
    Int costo();
    String nombre();
}

@Entity
public class Regalo extends Item{
    String fraseMotivacional;
    @Override costo(); @Override nombre();
}

@Entity
public class Accesorio extends Item{
    @Override costo(); @Override nombre();
}

@Entity
public class Arma extends Item{
    Int defensa;
    Int ataque;
    @Override costo(); @Override nombre();
}

@Entity
public class BolsaDeMonedas extends Item{
    Int monedas;
    @Override costo(); @Override nombre();
}

// TipoPersonaje --> ENUM (creo un enum que implemente la interfaz)
// no es necesario persistirlo, vive en Personaje como @Enumerated
// cada personaje no tiene atributos propios
// tiene el mismo comportamiento todos
// son stateless

public enum TipoPersonajeEnum implements TipoPersonaje{
    GUERRERO{
        @Override comerciar(); @Override pelear(); @Override buscarItem();
    }
    HECHICERO{
        @Override comerciar(); @Override pelear(); @Override buscarItem();
    }
    COMERCIANTE{
        @Override comerciar(); @Override pelear(); @Override buscarItem();
    }
}

// --- INTERFAZ REST ---



//-------------------------------------QUEMEPONGO-------------------------------------
@MappedSuperclass
public class PersistanceEntity{
    @Id @GeneratedValue
    private int id;
    // getter --> en parcial no hace falta I guess
    public int getID() {return id;}
}

@Entity
@Inheritance(strategy=SINGLE_TABLE)
@DiscriminatorColumn(name=tipoEvento, type=String)
public abstract class Evento{
    @ManyToOne //un user puede tener varios eventos
    @JoincColumn(name=usuario_id)
    Usuario usuario;
    private Date inicio;
    private Date fin;
    @Embedded //la ciudad no tiene comportamiento
    private String ciudad;
}

@Entity
@DiscriminatorValue(value="Unico")
public class EventoUnico extends Evento{
    @Override ocurreAproximadamente
}

@Entity
@DiscriminatorValue(value="Recurrente")
public class EventoRecurrente extends Evento{
    @Enumerated
    Recurrencia recurrencia;
    @Override ocurreAproximadamente
}

@Embeddable
public class Ciudad{
    private String key;
}

public enum Recurrencia implements Recurrencia{ // ya que cada subtipo no tiene atributos propios ni metodos distintos, lo transformo en enum
    SEMANAL{
        @Override proximaOcurrencia ...
    }
    MENSUAL{
        @Override proximaOcurrencia ...
    }
}

@Entity
public class Usuario{
@OneToMany
@JoincColumn(name=usuario_id)
Set <Prenda> guardarropas;
}

@Entity
public class Prenda{
    private String descripcion;
    @Enumerated
    private String categoria;
    @EllementCollection //en este caso el color sí tiene identidad (nombre y codigo)
    List <Color> colores;
}

@Embeddable
public class Color{
    private String descricpion;
    private String codigoHexa;
}

// sugerencia no se persiste = es el resultado de un cálculo --> objeto efimero



//-------------------------------------JUEGODETRONOS-------------------------------------
// https://docs.google.com/document/d/1Qjgq_KS73UUn8337LEoXi_M28wtgi-EkBuaQ7N-9Ks4/edit?usp=sharing
@MappedSuperclass
abstract class PersistanceEntity{
    @Id @GeneratedValue
    private Int id;
}


// lugar
@Entity
@Table('Lugares')
@Inheritance(JOINED)
abstract class Lugar extends PersistanceEntity{
//...
}

@Entity
@Table('Castillos')
class Castillo extends Lugar{
//...
}

@Entity
@Table('Ciudades')
class Ciudad extends Lugar{
//...
}


// fuerza militar
@Entity
@Table('Fuerzas_Militares')
@Inheritance(SINGLE_TABLE)
@DiscriminatorColumn('tipo')
abstract class FuerzaMilitar extends PersistanceEntity{
    //...
}

@Entity
@DiscriminatorValue('Area')
class Aerea extends FuerzaMilitar{
   Int cantidadDragones
}

@Entity
@DiscriminatorValue('Terrestre')
class Aerea extends FuerzaMilitar{
   Int cantidadSoldados
}
@Entity
@DiscriminatorValue('Naval')
class Aerea extends FuerzaMilitar{
   Int cantidadBarcos
}


// region
@Entity
@Table('Regiones')
class Region extends PersistentEntity{
  @ManyToMany
  Collection<Lugar> lugares

  @ManyToOne
  Casa casaPrincipal
}


// casa
@Entity
@Table('Casas')
class Casa{
  @ManyToOne
  Casa vasallaDe
 
  @ManyToOne
  Lugar origen

  @OneToMany
  @JoinColumn('casa_id') // va el id de la clase en donde estoy parada
  Collection<FuerzaMilitar> fuerzasMilitares
}



//-------------------------------------2CANCIONES-------------------------------------
// https://docs.google.com/document/d/1DGIFDVIsxbbpffSTyDEaR2m37GF4XSbDoXrUKoctvs4/edit?usp=sharing

abstract class PersistanceEntity{
    @Id @GeneratedValue
    int id;
}

// contenidos
// SINGLE_TABLE porque se quieren hacer bastantes consultas polimorficas (reproducciones)
// cambiamos unos campos null por la performance
// ademas, estos 2 subtipos comparten 2 atributos entre si
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name =tipo, type=String) // los atributos de las otras tablas, terminan todos en esta, pero eso SE VE EN EL DER
abstract class Contenido extends PersistanceEntity{
    @Enumerated
    Clasificacion clasificacion;
    @Embedded
    Estadistica estadistica;
    Usuario usuario;
}

@Entity
@DiscriminatorValue('podcast')
class Podcast extends Contenido{
    fechaInicio;
    fechaFin;
}

@Entity
@DiscriminatorValue('cancion')
class Cancion extends Contenido{
    duracion;
    subido;
}

// clasificaciones
// cada clasificacion no tiene atributos propios
// tiene el mismo comportamiento todos
// son stateless
// no es necesario persistirlo, vive en Contenido como @Enumerated
enum Clasificacion {
    MENORES{
        @Override validarAcceso(usuario);
    }
    ADOLESCENTES{
        @Override validarAcceso(usuario);
    }
    ADULTOS{
        @Override validarAcceso(usuario);
    }
}
// pd: no es necesario poner @Enumerated al principio de la clase, solo cuando lo referencio en la tabla donde vive

@Entity
class Playlist {
    @ManyToMany
    @JoinTable(name= contenidoPorPlaylist)
    @OrderColumn
    List<Contenido> contenidos;

    @ManyToMany
    @JoinTable('playlistXSuscriptor')
    List<Usuario> suscriptores;
    
    @Enumerated
    Visibilidad visibilidad;
    
    Usuario duenio; // deberia haber una relacion en la tabla Usuario --> ManyToOne
}

enum Visibilidad {
    PRIVADA, PUBLICA, NO_LISTADA
}

@Entity
class Usuario{
}

// EMBEDDABLE porque no tiene sentido vivir sin un contenido
// ademas, es algo que no suele cambiar con el tiempo, si se quiere una distinta se intancia una nueva
@Embeddable
class Estadistica{
    int likes;
    int dislikes;
}


//-------------------------------------RECUPERATORIO-------------------------------------
abstract class PersistanceEntity{
    @Id @GeneratedValue
    int id;
}

// uso estrategia JOINED para mapeo de herencia porque
// - cada clase tiene una serie de atributos propios (bastantes) --> podria ser table per class pero debemos priorizar las consultas polimorficas
// - comparten el atributo numero
// - deben cumplir el polimorfismo ya que se pide saber los asientos libres de un vuelo, para esto necesitara consultar a ambos tipos (no elegimos single table porque quedarian muchos campos null, aunque tendria mayor performance)
// - y en otros casos no deben cumplirlo(?)

// aca la opcion mas correcta hubiera sido un SINGLE_TABLE dado las consultas polimorficas --> se deben priorizar
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
abstract class Asiento extends PersistanceEntity{
    int numero
    // debe ser list porque tiene que mantener el orden (para que quede disponible para el proximo)
    @ManyToMany
    @JoinTable(name = AsientoXPasajero)
    List<Pasajero> enEspera
    @OneToOne
    @JoincColumn(name = id_Pasajero)
    Pasajero asignado
}

@Entity
@Table('Primera_Clase') // se puede poner en cada tabla para agregarle nombre --> extra
class PrimeraClase extends Asiento{
    pulgadasTv
    tipoComando
    masajeador
    comidaGourmet
}

@Entity
@Table('Turista')
class Turista extends Asiento{
    cubreCabeza
    almohada
    bolsaVomital
}

@Entity
@Table('Pasajero')
class Pasajero extends PersistanceEntity{
    nombre
    dni
    edad
    sexo
    @ManyToOne
    @JoinColumn(name=id_tipo)
    TipoPasajero tipo
}

// paso interfaz a abstract class
// estrategia de mapeo de herecia: SINGLE_TABLE ya que:
// ya que tenemos pocos atributos por separado en cada clase --> por lo que tendriamos pocos campos null (ademas tenemos solo 2 subclases)
// sirve para una consulta rapida al tener que buscar el precio de un asiento en base al tipo de pasajero
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name= tipo, type = String)
abstract class TipoPasajero extends PersistanceEntity{
}

@Entity
@DiscriminatorValue(value= "normal")
class Normal extends TipoPasajero{
    @Enumerated
    Categoria categoria
}

@Entity
class Frecuente extends TipoPasajero{
    nroPasajeroFrecuente
}
// PD: en esta desicion del tipo de pasajero, lo mas correcto hubiera sido hacer un enum (con comportamiento) ya que el tipo de pasajero es stateless

// no se persiste, vive como enumerated en normal
enum Categoria{
    A,B,C
}

@Entity
class Viaje extends PersistanceEntity{
    @ManyToMany
    @JoinTable(name = "AsientoXViaje",
               JoinColumn = @JoinColumn(name= id_viaje),
               InverseJoinColumn = @JoinColumn(name = id_asiento))
    List<Asiento> asientos
    @ManyToOne
    @JoinColumn(id_lugar)
    Lugar destino
    @ManyToOne(id_lugar)
    Lugar origen
}

// embeddable porque es value object
// 2 posiciones con la misma latitud y longitud representan a la misma posicion
// no existe por si mismo --> depende del lugar
@Embeddable
class Posicion{
    latitud
    longitud
}

@Entity
class Lugar extends PersistanceEntity{
    nombre, descripcion //...
    @Embedded
    Posicion posicion
}